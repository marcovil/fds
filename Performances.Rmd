---
title: "Performances"
output: html_document
date: "2023-03-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyr)
library(dplyr)
#library(repurrrsive)
library(jsonlite)
library(purrr)
library(stringr)
library(lubridate)
library(modelr)
library(broom)
library(tibble)
library(ggplot2)
library(mgcv)
```

Apro il file JSON, per come è fatto devo accedere al primo elemento e posso quindi caricarlo in un tibble.
Sono 14.536 liste.

```{r}
complete <- read_json("complete.json")
programs <- complete[[1]]
programsT <- tibble(programs)
```

A questo punto ho la possibilità di accedere ai programmi, controllo che siano tutte liste di lunghezza 6.

```{r}
programsT %>%
  mutate(programs_L = sapply(programs,length)) %>%
  filter(programs_L != 6)
```

Posso quindi espandere i programmi.

```{r}
programsT <- programsT %>% unnest_wider(programs)
programsT %>% distinct(programID)
programsT %>% select(programID) %>% n_distinct() # ci sono 14531 programmi
```

Nella maggior parte dei casi a un programma è associato un concerto, ma non è sempre così. In totale ci sono 22525 concerti.

```{r}
programsT %>%
  mutate(concerts_L=sapply(concerts,length)) %>%
  count(concerts_L) %>%
  mutate(concertN = concerts_L * n) %>%
  mutate(concertsT = cumsum(concertN)) %>%
  arrange(-concertsT)
```

Espando i concerti, ottengo una riga per ogni concerto. Passo da 14.536 a 22.525 righe. Aggiungo anche una colonna concertID. Passo a 7 colonne.

```{r}
programsT <- programsT %>% unnest_longer(concerts)
nrow(programsT)
programsT <- rowid_to_column(programsT,var = "concertID")
programsT <- select(programsT,id,programID,orchestra,season,concertID,concerts,works)
```

Verifico che ogni concerto abbia 5 campi.

```{r}
programsT %>%
  mutate(concerts_L = sapply(concerts, length)) %>%
  filter(concerts_L != 5)
```

Posso espandere con unnest_wider. Allargo il tibble di 4 colonne, al posto di concerts ho eventType, Location, Venue, Date e Time.

```{r}
programsT <- programsT %>% unnest_wider(concerts)

```

Come si può vedere, un programma può contenere più concerti.

```{r}
programsT %>% group_by(programID) %>% count(sort = TRUE)
```

Per esempio il programma 10700 contiene 16 concerti. In questo caso vediamo anche che di alcuni concerti non è indicata l'ora.
Per questo motivo ho introdotto un concertID, se in seguito mi fossi limitato a identificare il concerto con eventType, Location, Venue, Date, Time, avrei perso alcuni concerti.

```{r}
programsT %>%
  filter(programID == 10700)
```

Ogni programma contiene un certo numero di lavori (works). In totale ci sono 125.224 works (si tratta di works che possono essere ripetuti in diversi programs).	

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L) %>%
  mutate(works_N = works_L * n) %>%
  mutate(works_T = cumsum(works_N)) %>%
  arrange(-works_T)
```

Ci sono dei program che hanno 0 works, che cosa sono? Si tratta di eventi che non prevedono musica o dei quali mancano informazioni.

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  filter(works_L == 0)
```

Posso utilizzare unnest_longer, ogni lavoro associato a un programma darà origine a una riga. Devo usare l'opzione keep_empty TRUE per non perdere le righe con zero works.
Quindi il tibble passerà a 125.224 + 29 righe, ovvero 125.253.

```{r}
programsT <- programsT %>% unnest_longer(works, keep_empty = TRUE)
programsT %>% filter(programID == 13665)
```

Ora works contiene liste di lunghezze diverse, a seconda delle caratteristiche del work compreso. 

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L)
```

Le liste di lunghezza 3 sono quelle che contengono le intermissions.

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 3) %>%
  select(works) %>%
  unnest_wider(works) %>%
  count(ID, interval, soloists)
```

Cerco di capire cosa contengono le altre liste (di lunghezza 4, 5 e 6). 

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 4) %>%
  select(works) %>%
  unnest_wider(works)
```

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 5) %>%
  select(works) %>%
  unnest_wider(works)
```

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 6) %>%
  select(works) %>%
  unnest_wider(works)
```

Faccio unnest_wider di works. Passo da 11 colonne a 17 (al posto di works si aggiungono tutte le colonne comuni ai diversi works, ovvero ID, composerName, workTitle, movement, conductorName, soloists, interval)

```{r}
programsT <- programsT %>% unnest_wider(works)
```

Passo a prendere in considerazione workTitle.

```{r}
programsT %>%
  mutate(workTitle_L = sapply(workTitle,length)) %>%
  count(workTitle_L)
```

Come sono gli elementi di lunghezza 2.

```{r}
programsT %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  pull(workTitle) %>%
  head(3)
```

Mi salvo i program ID per ritrovarli dopo la modifica.

```{r}
wt2ids <- programsT %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  select(ID)
```

Applico funzione per sistemarli (sistemo anche NA al posto di NULL), faccio semi_join con gli id per verificare il risultato su quelli di lunghezza 2.

```{r}
mod_w <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (combine_w(x[[1]], x[[2]]))
}

combine_w <- function(x,y) {
  if (startsWith(x,",")) {
    return (paste(y,x))
  } else {
    return (paste(x,y))
  }
}

programsT %>%
  mutate(workTitle = sapply(workTitle, mod_w)) %>%
  semi_join(wt2ids) %>%
  select(workTitle)
```

Eseguo l'operazione e ri-assegno a programsT.

```{r}
programsT <- programsT %>%
  mutate(workTitle = sapply(workTitle, mod_w))
```

Verifico la lunghezza degli elementi contenuti in movement.

```{r}
programsT %>%
  mutate(movement_L = sapply(movement, length)) %>%
  count(movement_L)
```

Vedo come sono quelli di lunghezza 2.

```{r}
programsT %>%
  mutate(movement_L = sapply(movement, length)) %>%
  filter(movement_L == 2)
```

Mi limito a concatenarli, con la funzione mod_m. Inoltre sostituisco i NULL con NA.

```{r}
mod_m <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (paste(x[[1]], "_", x[[2]]))
}

programsT <- programsT %>% mutate(movement = sapply(movement, mod_m))
```

Controllo la lunghezza delle liste contenute in soloists. Ho 89.321 potenziali righe di informazioni su solisti + 85.122 righe nulle.

```{r}
programsT %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  count(soloists_L) %>%
  mutate(soloists_N = soloists_L * n) %>%
  mutate(soloists_T = cumsum(soloists_N)) %>%
  filter(soloists_L == 0 | soloists_L == max(soloists_L))
```

Provo unnest_longer di soloists con opzione keep_empty per tenere anche le righe che contengono liste NULL e vedo che sono di lunghezza 0 o 3.

```{r}
programsT %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  count(soloists_L)
```

Ce ne sono cinque che sono di lunghezza 1, ma poi NULL.

```{r}
programsT %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  filter(soloists_L != 0) %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  mutate(soloists_L2 = sapply(soloists, length)) %>%
  filter(soloists_L2 == 0)
```

Per esempio.

```{r}
programsT %>%
  filter(programID == 14489)
```


```{r}
programsT %>%
  filter(concertID == 1)
```

Faccio quindi unnest_longer, poi unnest_wider, il numero di colonne passa da 17 a 19 (soloistName, soloistInstrument e soloistRoles al posto di soloists).

```{r}
programsT <- programsT %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  unnest_wider(soloists)
programsT
```

id rappresenta il GUID, che fa parte dell'indirizzo a cui è possibile vedere il programma online (archives.nyphil.org/index.php/artifact/GUID/fullview).
ci sono tre programID che sono associati a più GUID.
Tengo comunque la colonna id.

```{r}
ids <- programsT %>%
  distinct(id, programID) %>%
  group_by(programID) %>%
  count(sort = TRUE) %>%
  filter(n>1) %>%
  select(programID) %>%
  ungroup()

semi_join(programsT, ids) %>%
  distinct(id, programID) %>%
  select(id, programID)
```

Correggo come è scritta la data, aggiungo anche componenti anno, mese, giorno della data.

```{r}

#ci sono 5591 righe che contengono None invece dell'orario in formato AM o PM
programsT %>%
  mutate(trovato = str_detect(programsT$Time, "\\d{1,2}:\\d{1,2}[P,A]M")) %>%
  filter(trovato == FALSE)

# lascio Time com'è, sistemo la data, tenendo anche anno, mese, giorno
programsT <- programsT %>%
  mutate(Date = str_extract(Date, "[[:digit:]-]+")) %>%
  mutate(Date = ymd(Date)) %>%
  mutate(Year = year(Date)) %>%
  mutate(Month = month(Date)) %>%
  mutate(Day = day(Date)) %>%
  select(id, programID, orchestra, season, concertID, eventType, Location, Venue, Date, Year, Month, Day, Time, ID, composerName, workTitle, conductorName, soloistName, soloistInstrument, soloistRoles, movement, interval)

```

Divido ID in workID e movementID

```{r}
programsT <- programsT %>%
  separate(ID, into = c("workID", "movID"), sep = "\\*") %>%
  mutate(workID = as.integer(workID)) %>%
  mutate(movID = as.integer(movID))
```

Ci sono delle celle con valori multipli.

```{r}
programsT %>%
  mutate(co_conductor = str_detect(conductorName, ";")) %>%
  filter(co_conductor)
```

Correggo un errore (un conductorName scritto come "de Waart, Edo;  ;  ;  de Waart, Edo").

```{r}
programsT <- programsT %>%
  mutate(conductorName = if_else(str_detect(conductorName, ";\\s*;\\s*;"), "de Waart, Edo", conductorName))
```

Modifico aggiungendo una colonna che indica la presenza di co-conduzione.

```{r}
programsT <- programsT %>%
  mutate(conductorName = str_remove(conductorName, "^; ")) %>%
  mutate(co_conductor = str_detect(conductorName, ";")) %>%
  separate_longer_delim(conductorName, "; ")
```

Costruisco un tibble ridotto per le analisi successive.

```{r}
ccseason <- programsT %>%
  filter(is.na(interval)) %>%
  distinct(eventType,concertID, Date, composerName, workTitle, conductorName, co_conductor) %>%
  mutate(year = year(Date))
```

ANDAMENTO CONCERTI NELLE STAGIONI

Creo un tibble con solo i concerti.

```{r}
concerts <- ccseason %>%
  distinct(concertID, Date, year, eventType)
```

Numero di concerti per anno nel tempo.

```{r}
concerts %>%
  group_by(year) %>%
  count() %>%
  ggplot(mapping = aes(x = year, y = n)) + 
  geom_point() +
  geom_smooth()
```

Dal 2015 in poi.

```{r}
concerts %>%
  group_by(year) %>%
  count() %>%
  ggplot(mapping = aes(x = year, y = n)) + 
  geom_line() +
  coord_cartesian(xlim = c(2015, 2023))
```

Che tipi di concerti ci sono.

```{r}
concerts %>%
  group_by(eventType) %>%
  count() %>%
  filter(n > 100) %>%
  ggplot(aes(x = n, y = eventType)) +
  geom_bar(stat = "identity")
```

Ci sono differenze fra Subscription Season e il resto? Mi limito al periodo fino al 2019.

```{r}
concerts %>%
  filter(year <= 2019) %>%
  mutate(group = if_else(eventType == "Subscription Season", "SUB", "REST")) %>%
  group_by(year,group) %>%
  count() %>%
  ggplot(aes(x = year, y = n, colour = group)) +
  geom_point() +
  geom_smooth()
```

Andamento negli anni delle altre tipologie di concerti.

```{r}
concerts %>%
  filter(year <= 2019) %>%
  filter(eventType != "Subscription Season") %>%
  group_by(year) %>%
  count() %>%
  ggplot(mapping = aes(x = year, y = n)) + 
  geom_point() +
  geom_smooth()
```

Mi concentro sul periodo che va dal 1975 ad oggi.

```{r}
concerts %>%
  filter(year >= 1975 & year < 2020) %>%
  mutate(group = if_else(eventType == "Subscription Season", "SUB", "REST")) %>%
  group_by(year,group) %>%
  count() %>%
  ggplot(aes(x = year, y = n, colour = group)) +
  geom_point() +
  geom_smooth()
```

Quali sono gli eventType preponderanti dal 1990 in poi?

```{r}
concerts %>%
  filter(year >= 1990 & year < 2020) %>%
  filter(eventType != "Subscription Season") %>%
  group_by(year,eventType) %>%
  count() %>%
  ggplot(aes(x = year, y = n, color = eventType)) +
  geom_line(alpha = 1/2, show.legend = FALSE)
```
Fra gli eventi che non fanno parte della stagione regolare, quelli più presenti con maggior continuità sono i tour e i concerti da camera.

```{r}
concerts %>%
  filter(year >= 1990 & year < 2020) %>%
  filter(eventType != "Subscription Season") %>%
  group_by(year,eventType) %>%
  count() %>%
  group_by(year) %>%
  mutate(yearEvents = sum(n)) %>%
  ungroup() %>%
  mutate(perc = n / yearEvents) %>%
  group_by(year) %>%
  mutate(order = row_number(-perc)) %>%
  filter(order <= 2) %>%
  ungroup() %>%
  ggplot() +
  geom_line(aes(year, n, color = eventType))
```

Come si è evoluto negli anni il numero di rappresentazioni per compositore.

```{r}
ccseason %>%
  mutate(year = year(Date)) %>%
  filter(!is.na(composerName)) %>%
  group_by(year,composerName) %>%
  count() %>%
  ggplot() +
  geom_line(alpha = 1/2, aes(year, n, color = composerName), show.legend = FALSE) +
  geom_line(aes(year,n), rap_anno)
```

Costruisco un modello lineare anno-rappresentazioni per tutti i compositori. Tolgo i compositori che compaiono per meno di 10 anni.

```{r}
tenorless <- ccseason %>%
  filter(eventType == "Subscription Season") %>%
  filter(!is.na(composerName)) %>%
  mutate(year = year(Date)) %>%
  group_by(composerName) %>%
  summarise(years = n_distinct(year)) %>%
  filter(years <= 10)

yc <- ccseason %>%
  filter(eventType == "Subscription Season") %>%
  filter(!is.na(composerName)) %>%
  mutate(year = year(Date)) %>%
  anti_join(tenorless) %>%
  group_by(composerName,year) %>%
  count() %>%
  group_by(composerName) %>%
  nest()

yc_model <- function(df) {
  lm(n ~ year, data = df)
}

yc <- yc %>%
  mutate(model = map(data, yc_model))

yc <- yc %>% 
  mutate(data = map2(data, model, add_residuals))

models <- yc %>%
  mutate(model = map(model, tidy)) %>%
  unnest(cols = c(model))

slopes <- models %>%
  filter(term == "year")

slopes %>%
  ggplot() +
  geom_histogram(aes(x=estimate))

upslopes <- slopes %>%
  arrange(-estimate) %>%
  head(15)

downslopes <- slopes %>%
  arrange(estimate) %>%
  head(15)

models %>%
  unnest(data) %>%
  semi_join(upslopes) %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

models %>%
  unnest(data) %>%
  semi_join(downslopes) %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

ccseason %>%
  filter(composerName == "Wagner,  Richard") %>%
  mutate(year = year(Date)) %>%
  group_by(year) %>%
  count() %>%
  ungroup() %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth()
```

Vedo come sono i residui.

```{r}
resids <- unnest(yc, data)

resids %>%
  group_by(composerName)
  
yc <- yc %>% 
  mutate(glance = map(model, broom::glance))
  
glance = unnest(yc, glance)

glance %>%
  arrange(r.squared)
  
worst_fit <- glance %>%
  arrange(r.squared) %>%
  head(20)

best_fit <- glance %>%
  arrange(-r.squared) %>%
  head(20)

models %>%
  unnest(data) %>%
  semi_join(worst_fit, by="composerName") %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

models %>%
  unnest(data) %>%
  semi_join(best_fit, by="composerName") %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)
```

```{r}
top_resids <- resids %>%
  arrange(-resid) %>%
  head(20)

bot_resids <- resids %>%
  arrange(resid) %>%
  head(50)

models %>%
  unnest(data) %>%
  semi_join(top_resids, by="composerName") %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

models %>%
  unnest(data) %>%
  semi_join(bot_resids, by="composerName") %>%
  ggplot(aes(x = year, y = n)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

```

Stessa cosa ma lavorando con le percentuali.

```{r}
ccseason %>%
  mutate(year = year(Date)) %>%
  filter(eventType == "Subscription Season") %>%
  filter(!is.na(composerName)) %>%
  group_by(year,composerName) %>%
  count() %>%
  group_by(year) %>%
  mutate(totalYear = sum(n)) %>%
  ungroup() %>%
  mutate(perc = n / totalYear) %>%
ggplot(aes(year, perc, color = composerName)) +
  geom_line(alpha = 1/2, show.legend = FALSE)
```

Costruisco un modello lineare anno-rappresentazioni per tutti i compositori. Tolgo i compositori che compaiono per meno di 10 anni.

```{r}
ycp <- ccseason %>%
  mutate(year = year(Date)) %>%
  filter(!is.na(composerName)) %>%
  anti_join(tenorless) %>%
  group_by(year,composerName) %>%
  count() %>%
  group_by(year) %>%
  mutate(totalYear = sum(n)) %>%
  ungroup() %>%
  mutate(perc = n / totalYear) %>%
  group_by(composerName) %>%
  nest()

ycp_model <- function(df) {
  lm(perc ~ year, data = df)
}

ycp <- ycp %>%
  mutate(model = map(data, yc_model))

ycp <- ycp %>% 
  mutate(data = map2(data, model, add_residuals))

modelsp <- ycp %>%
  mutate(model = map(model, tidy)) %>%
  unnest(cols = c(model))

slopesp <- modelsp %>%
  filter(term == "year")

slopesp %>%
  ggplot() +
  geom_histogram(aes(x=estimate))

upslopesp <- slopesp %>%
  arrange(-estimate) %>%
  head(15)

downslopesp <- slopesp %>%
  arrange(estimate) %>%
  head(15)

modelsp %>%
  unnest(data) %>%
  semi_join(upslopesp) %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  facet_wrap(~composerName)

modelsp %>%
  unnest(data) %>%
  semi_join(downslopesp) %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  facet_wrap(~composerName)

modelsp %>%
  unnest(data) %>%
  filter(composerName == "Mozart,  Wolfgang  Amadeus") %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  geom_smooth()

modelsp %>%
  unnest(data) %>%
  filter(composerName == "Beethoven,  Ludwig  van") %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  geom_smooth()

ccseason %>%
  filter(composerName == "Beethoven,  Ludwig  van") %>%
  mutate(year = year(Date)) %>%
  group_by(year) %>%
  count() %>%
  ungroup() %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  geom_smooth()

```

Vedo come sono i residui.

```{r}
residsp <- unnest(ycp, data)

residsp %>%
  group_by(composerName)
  
ycp <- ycp %>% 
  mutate(glance = map(model, broom::glance))
  
glancep = unnest(ycp, glance)

glancep %>%
  arrange(r.squared)
  
worst_fitp <- glance %>%
  arrange(r.squared) %>%
  head(20)

best_fitp <- glance %>%
  arrange(-r.squared) %>%
  head(20)

modelsp %>%
  unnest(data) %>%
  semi_join(worst_fitp, by="composerName") %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  facet_wrap(~composerName)

modelsp %>%
  unnest(data) %>%
  semi_join(best_fitp, by="composerName") %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  facet_wrap(~composerName)
```

Residui.

```{r}
top_residsp <- residsp %>%
  arrange(-resid) %>%
  head(20)

bot_residsp <- residsp %>%
  arrange(resid) %>%
  head(20)

modelsp %>%
  unnest(data) %>%
  semi_join(top_residsp, by="composerName") %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

modelsp %>%
  unnest(data) %>%
  semi_join(bot_residsp, by="composerName") %>%
  ggplot(aes(x = year, y = perc)) +
  geom_line() +
  geom_smooth() +
  facet_wrap(~composerName)

```

Come sono composti i repertori dei conduttori? Considero i lavori e non i movimenti.

```{r}
ccseason %>%
  group_by(conductorName,composerName) %>%
  count() %>%
  group_by(conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  ggplot() +
  geom_histogram(aes(x = perc), binwidth = 0.01, boundary = 0)

ccseason %>%
  group_by(conductorName,composerName) %>%
  count() %>%
  group_by(conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  ungroup() %>%
  count(cut_width(perc, 0.01, boundary = 0))

ccseason %>%
  group_by(conductorName,composerName) %>%
  count() %>%
  group_by(conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  ungroup() %>%
  pull(perc) %>%
  quantile(na.rm = TRUE)


```

Chi si è concentrato soprattutto su un solo autore? Escludendo chi ha condotto solo opere di un autore.

```{r}
ccseason %>%
  group_by(conductorName,composerName) %>%
  count() %>%
  group_by(conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  filter(perc > 0.5 & perc < 1) %>%
  arrange(-perc)
```

```{r}
ccseason %>%
  group_by(conductorName,composerName) %>%
  count() %>%
  group_by(conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  filter(perc == 1) %>%
  arrange(-total)
```

Come sono evoluti i repertori dei direttori nel corso degli anni?

```{r}
perctime <- ccseason %>%
  filter(!is.na(conductorName)) %>%
  filter(conductorName != "Not conducted") %>%
  mutate(year = year(Date)) %>%
  group_by(year) %>%
  count(conductorName,composerName) %>%
  group_by(year,conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  group_by(conductorName,composerName) %>%
  mutate(compYears = n_distinct(year)) %>%
  ungroup() %>%
  filter(compYears >=5)

nested_pt <- perctime %>%
  group_by(conductorName,composerName) %>%
  nest()

modelf <- function(df) {
  lm(perc ~ year, data = df)
}

nested_pt_models <- 
  nested_pt %>%
  mutate(model = map(data, modelf))

top <- nested_pt_models %>%
  mutate(model = map(model,tidy)) %>%
  unnest(cols = c(model)) %>%
  filter(term == "year") %>%
  filter(p.value < 0.05) %>%
  arrange(-estimate) %>%
  head(10)

bot <- nested_pt_models %>%
  mutate(model = map(model,tidy)) %>%
  unnest(cols = c(model)) %>%
  filter(term == "year") %>%
  filter(p.value < 0.05) %>%
  arrange(estimate) %>%
  head(10)


perctime %>%
  inner_join(top, join_by("composerName","conductorName")) %>%
  ggplot(aes(year, perc, color = composerName)) +
  geom_line() +
  facet_wrap(~conductorName)

perctime %>%
  inner_join(bot, join_by("composerName","conductorName")) %>%
  ggplot(aes(year, perc, color = composerName)) +
  geom_line() +
  facet_wrap(~conductorName)
```

```{r}
perctime %>%
  filter(conductorName == "Boulez, Pierre") %>%
  ggplot() +
  geom_line(aes(x = year, y = perc, color = composerName))
```

```{r}
perctime %>%
  filter(conductorName == "Boulez, Pierre") %>%
  ggplot() +
  geom_line(aes(x = year, y = n, color = composerName))
```



```{r}
perctime %>%
  filter(conductorName == "Masur, Kurt") %>%
  ggplot() +
  geom_line(aes(x = year, y = perc, color = composerName))
```

```{r}
perctime %>%
  filter(conductorName == "Masur, Kurt") %>%
  ggplot() +
  geom_line(aes(x = year, y = n, color = composerName))
```


```{r}
perctime %>%
  filter(conductorName == "Masur, Kurt") %>%
  ggplot() +
  geom_point(aes(x = year, y = n))
```


```{r}
perctime_2 <- ccseason %>%
  filter(!is.na(conductorName)) %>%
  filter(conductorName != "Not conducted") %>%
  mutate(year = year(Date)) %>%
  group_by(year) %>%
  count(conductorName,composerName) %>%
  group_by(year,conductorName) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  group_by(conductorName,composerName) %>%
  mutate(compYears = n_distinct(year)) %>%
  mutate(year_2 = year**2) %>%
  ungroup() %>%
  filter(compYears >=5)

nested_pt_2 <- perctime_2 %>%
  group_by(conductorName,composerName) %>%
  nest()

modelf2 <- function(df) {
  lm(perc ~ year + year_2, data = df)
}

nested_pt_models_2 <- 
  nested_pt_2 %>%
  mutate(model = map(data, modelf2))

top <- nested_pt_models_2 %>%
  mutate(model = map(model,tidy)) %>%
  unnest(cols = c(model)) %>%
  filter(term == "year_2") %>%
  filter(p.value < 0.05) %>%
  arrange(-estimate) %>%
  head(10)

bot <- nested_pt_models_2 %>%
  mutate(model = map(model,tidy)) %>%
  unnest(cols = c(model)) %>%
  filter(term == "year_2") %>%
  filter(p.value < 0.05) %>%
  arrange(estimate) %>%
  head(10)

```

```{r}
perctime %>%
  inner_join(top, join_by("composerName","conductorName")) %>%
  ggplot(aes(year, perc, color = composerName)) +
  geom_line() +
  facet_wrap(~conductorName)
```












































































Quanti programmi ci sono nel dataset?

```{r}
prova %>% group_by(Time) %>% count(sort = TRUE)

prova %>% group_by(Location) %>% count(sort = TRUE)

prova %>% filter(programID == 13158)
```



La colonna "interval" contiene intermission di vari tipi.

```{r}
intervalNA <- programsT %>%
  filter(!is.na(interval)) %>%
  count()

intervalNome <- programsT %>%
  filter(str_detect(interval, "Intermission")) %>%
  count()
  
intervalNA == intervalNome
```

Compositori & direttori.

```{r}
cc <- programsT %>%
  filter(is.na(interval)) %>%
  distinct(concertID, Date, composerName, workTitle, conductorName)
  
cc %>%
  group_by(conductorName) %>%
  n_distinct(Date)

cc %>%
  filter(is.na(composerName))
  
programsT %>%
  filter(concertID == 577)
```

```{r}

```



Primo e ultimo concerto per direttori. Densità di concerti.

```{r}
ccn <- cc %>%
  filter(!is.na(conductorName), conductorName != "Not conducted") %>%
  distinct(concertID,conductorName) %>%
  group_by(conductorName) %>%
  count()

cc %>%
  filter(!is.na(conductorName), conductorName != "Not conducted") %>%
  group_by(conductorName) %>%
  summarise (
    first = min(Date),
    last = max(Date),
    span = last - first + 1
  ) %>%
  inner_join(ccn) %>%
  mutate(c2d = n / as.integer(span)) %>%
  arrange(-c2d,-n)

cc %>%
  filter(conductorName == "Abbado, Roberto") 

cc %>%
  filter(conductorName == "Ravel, Maurice")

cc %>%
  filter(conductorName == "Alsop, Marin")

```

Primi cinquanta compositori per numero di concerti.

```{r}
ct50 <- cc %>%
  distinct(concertID, composerName) %>%
  group_by(composerName) %>%
  count() %>%
  arrange(-n) %>%
  select(composerName) %>%
  head(50)

cc %>%
  distinct(concertID,Date,composerName) %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month,monthid,composerName) %>%
  count() %>%
  inner_join(ct50,join_by(composerName)) %>%
  ggplot() +
  geom_tile(aes(x=reorder(month,monthid),y=composerName,fill=n))
```

Compositori che sono particolarmente rappresentati in un certo mese.
Globalmente, considerando i lavori rappresentati, sulla base della percentuale all'interno del mese.

```{r}
cc %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  mutate(percent = totalC / totalM) %>%
  filter(percent > 0.01) %>%
  ggplot() +
    geom_tile(aes(x=reorder(month,monthid),y=composerName,fill=percent))
```

George Gershwin.

```{r}
cc %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  mutate(percent = totalC / totalM) %>%
  filter(composerName == "Gershwin,  George")
  
cc %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  mutate(percent = totalC / totalM) %>%
  filter(composerName == "Gershwin,  George") %>%
  ggplot() +
    geom_point(aes(x=reorder(month,monthid),y=percent))
```

Beethoven.

```{r}
cc %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  mutate(percent = totalC / totalM) %>%
  filter(composerName == "Beethoven,  Ludwig  van") %>%
  ggplot() +
    geom_point(aes(x=reorder(month,monthid),y=percent))

```

Inizio e fine delle subscription season.

```{r}
programsT %>%
  filter(eventType == "Subscription Season") %>%
  group_by(season) %>%
  mutate(
    start = min(Date),
    end = max(Date)
  ) %>%
  ggplot() +
  geom_point(aes(x=season,y=month(start), color="red")) +
  geom_point(aes(x=season,y=month(end), color="blue"))

```


Concentrandomi sulla subscription season.

```{r}

  
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  mutate(percent = totalC / totalM) %>%
  filter(percent > 0.01) %>%
  ggplot() +
    geom_tile(aes(x=reorder(month,monthid),y=composerName,fill=percent))

```

Beethoven.

```{r}
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  mutate(percent = totalC / totalM) %>%
  filter(composerName == "Beethoven,  Ludwig  van") %>%
  ggplot() +
    geom_point(aes(x=reorder(month,monthid),y=percent))
```

```{r}
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  filter(as.integer(month(Date)) == 8) %>%
  filter(composerName == "Beethoven,  Ludwig  van") %>%
  ggplot() +
  geom_point(aes(x=Date,y=))
```

Subscription Season con normalizzazione.

```{r}
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  ungroup() %>%
  group_by(month) %>%
  mutate(
    normalized = (totalC - min(totalC)) / (max(totalC) - min(totalC))
  ) %>%
  distinct(composerName,month,monthid,normalized) %>%
  filter(normalized > 0.2) %>%
  ggplot() +
    geom_tile(aes(x=reorder(month,monthid),y=composerName,fill=normalized))
```

Globale con normalizzazione.

```{r}
ccseason %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  ungroup() %>%
  group_by(month) %>%
  mutate(
    normalized = (totalC - min(totalC)) / (max(totalC) - min(totalC))
  ) %>%
  distinct(composerName,month,monthid,normalized) %>%
  filter(normalized > 0.2) %>%
  ggplot() +
    geom_tile(aes(x=reorder(month,monthid),y=composerName,fill=normalized))
```

Diverso da subscription con normalizzazione.

```{r}

ccseason %>%
  filter(eventType != "Subscription Season") %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  ungroup() %>%
  group_by(month) %>%
  mutate(
    normalized = (totalC - min(totalC)) / (max(totalC) - min(totalC))
  ) %>%
  distinct(composerName,month,monthid,normalized) %>%
  filter(normalized > 0.2) %>%
  ggplot() +
    geom_tile(aes(x=reorder(month,monthid),y=composerName,fill=normalized))

```


```{r}
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  group_by(month) %>%
  mutate(totalM = n()) %>%
  group_by(composerName,add=TRUE) %>%
  mutate(totalC = n()) %>%
  filter(monthid == 5) %>%
  distinct(composerName,totalC) %>%
  arrange(-totalC)
```

```{r}
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  mutate(month = format(Date, "%B"), monthid = as.integer(month(Date))) %>%
  filter(monthid == 7)
```




```{r}
ccseason %>%
  filter(eventType == "Subscription Season") %>%
  mutate(Year = year(Date)) %>%
group_by(Year,composerName) %>%
  count() %>%
ggplot(aes(Year, n, color = composerName)) +
  geom_line(alpha = 1/2, show.legend = FALSE)
```




