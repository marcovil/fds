---
title: "Performances"
output: html_document
date: "2023-03-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyr)
library(dplyr)
library(repurrrsive)
library(jsonlite)
library(purrr)
library(stringr)
library(lubridate)
```

Apro il file JSON, per come è fatto devo accedere al primo elemento e posso quindi caricarlo in un tibble.

```{r}
complete <- read_json("complete.json")
programs <- complete[[1]]
programsT <- tibble(programs)
```

A questo punto ho la possibilità di accedere ai programmi, controllo che siano tutte liste di lunghezza 6.
Qui dovrei anche controllare che contengono tutte gli stessi nomi...

```{r}
programsT %>%
  mutate(programs_L=sapply(programs,length)) %>%
  filter(programs_L != 6)
```

Posso quindi espandere i programmi.

```{r}
programsT <- programsT %>% unnest_wider(programs)
```

Nella maggior parte dei casi a un programma è associato un concerto, ma non è sempre così. 

```{r}
programsT %>%
  mutate(concerts_L=sapply(concerts,length)) %>%
  count(concerts_L)
```

Espando i concerti, ottengo una riga per ogni concerto.

```{r}
programsT <- programsT %>% unnest_longer(concerts)
```

Verifico che ogni concerto abbia 5 campi.

```{r}
programsT %>%
  mutate(concerts_L = sapply(concerts, length)) %>%
  filter(concerts_L != 5)
```

Posso espandere con unnest_wider. Allargo il tibble di 4 colonne, al posto di concerts ho eventType, Location, Venue, Date e Time.

```{r}
programsT <- programsT %>% unnest_wider(concerts)
```

Ogni programma contiene un certo numero di lavori (works).

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L)
```

Posso utilizzare unnest_longer, ogni lavoro associato a un programma darà origine a una riga.

```{r}
programsT <- programsT %>% unnest_longer(works)
```

Ora works contiene liste di lunghezze diverse, a seconda delle caratteristiche del lavoro. 

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L) %>%
  add_tally(n)
```

Le liste di lunghezza 3 sono quelle che contengono le intermissions.

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 3) %>%
  pull(works) %>%
  head(5)
```

Cerco di capire che cosa contengono.

```{r}
works <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 3) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

first <- works[[1]]

identical_to_first <- lapply(works, identical, first)

works4 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 4) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works4_first <- works4[[1]]
id_to_first_w4 <- lapply(works4, identical, works4_first)
every(id_to_first_w4, isTRUE)

works5 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 5) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works5_first <- works5[[1]]
id_to_first_w5 <- lapply(works5, identical, works5_first)
every(id_to_first_w5, isTRUE)
detect_index(id_to_first_w5, isFALSE)
works5[[18]]
length(id_to_first_w5)
sum(unlist(id_to_first_w5))

works6 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 6) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works6_first <- works6[[1]]
id_to_first_w6 <- lapply(works6, identical, works6_first)
every(id_to_first_w6, isTRUE)

```

Faccio unnest_wider di works, controllo di aver mantenuto le informazioni di partenza.

```{r}
programsT <- programsT %>% mutate(works_L = sapply(works, length))
prova <- programsT %>% unnest_wider(works)
prova %>% filter(works_L == 3) # deve essere 18489
prova %>% filter(works_L == 4)
prova %>% filter(works_L == 5)
prova %>% filter(works_L == 6)
prova %>% filter(!is.na(conductorName))
prova
```

Controllo la lunghezza delle liste contenute in soloists.

```{r}
# da fare meglio
```

Faccio unnest_longer() su solisti e quindi unnest_wider().

```{r}
prova <- unnest_longer(prova, soloists, keep_empty = TRUE) # spiegare perché
prova <- unnest_wider(prova, soloists) # aumento da 17 a 19 le colonne ? e mi sono anche sistemato il problema del NULL
```

Verifico la lunghezza degli elementi contenuti in movement. Ci sono 148 elementi che hanno lunghezza 2.

```{r}
prova %>%
  mutate(movement_L = sapply(movement, length)) %>%
  count(movement_L)
```

Guardo a quelli che hanno lunghezza 2.

```{r}
prova %>%
  mutate(movement_L = sapply(movement, length)) %>%
  filter(movement_L == 2)
```

Applico la funzione mod_m per sistemare. Sostanzialmente serve a concatenare quelli che hanno lunghezza 2.
Inoltre sostituisco i NULL con NA.

```{r}
mod_m <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (paste(x[[1]], "_", x[[2]]))
}

prova <- prova %>% mutate(movement = sapply(movement, mod_m))
```

Ora devo lavorare anche su worktitle, controllo lunghezze.

```{r}
prova %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  count(workTitle_L)
```

Come sono gli elementi di lunghezza 2.

```{r}
prova %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  pull(workTitle)

# ricordarsi quelli strani (esempio quello che contiene Parsifal)

```

Applico funzione per sistemarli

```{r}
mod_w <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (combine_w(x[[1]], x[[2]]))
}

combine_w <- function(x,y) {
  if (startsWith(x,",")) {
    return (paste(y,x))
  } else {
    return (paste(x,y))
  }
}

prova <- prova %>% mutate(workTitle = sapply(workTitle, mod_w))

prova %>%
  filter(str_detect(workTitle, "PROCESSION"))
```

Correggo come è scritta la data.

```{r}
prova %>% separate(Date, into = c("date", "time"), sep = "T") %>%
  count(time)

# elimino time perché non è attendibile
prova %>%
  separate(Date, into = c("date", "time"), sep = "T") %>%
  unite(new, date, Time, sep = " ") %>%
  select(-time) %>%
  mutate(Date = parse_date_time(new, "%y-%m-%d %H:%M%p")) %>%
  select(-new) %>%
  select(id, programID, orchestra, season, eventType, Location, Venue, Date, everything())
```

Posso rimuovere la colonna id?

```{r}
p1 <- prova %>% select(programID, id)
p2 <- p1
anti_join(p1, p2, by=c("programID", "id"))
anti_join(p1, p2, by=c("id", "programID"))
prova %>% group_by("id") %>% group_by("programID") %>% count()
inner_join(p1,p2,"id")
distinctALL <- distinct(p1, programID, id)
distinctID <- prova %>% distinct(id)
distinctPID <- prova %>% distinct(programID)
anti_join(distinctALL,distinctPID)
str(prova)

all(!is.na(prova$id))
all(!is.na(prova$programID))
p2 <- rename(p2,programID2 = programID, id2 = id)
check <- tibble(p1,p2)

checkf <- function(a,b,c,d) {
  if (a == b) {
    if (b == d) {
      return (TRUE)
    } else {
      return (FALSE)
    }
  }
}
str(check)
sapply(check, checkf, a = programID, b = id, c = programID2, d = id2)
pmap(check,checkf)
```

Quanti programmi ci sono nel dataset?

```{r}
prova %>% group_by(Time) %>% count(sort = TRUE)

prova %>% group_by(Location) %>% count(sort = TRUE)

prova %>% filter(programID == 13158)
```

