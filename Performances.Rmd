---
title: "Performances"
output: html_document
date: "2023-03-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyr)
library(dplyr)
#library(repurrrsive)
library(jsonlite)
library(purrr)
library(stringr)
library(lubridate)
library(modelr)
library(broom)
library(tibble)
library(ggplot2)
library(mgcv)
```

Apro il file JSON, per come è fatto devo accedere al primo elemento e posso quindi caricarlo in un tibble.
Sono 14.536 liste.

```{r}
complete <- read_json("complete.json")
programs <- complete[[1]]
programsT <- tibble(programs)
```

A questo punto ho la possibilità di accedere ai programmi, controllo che siano tutte liste di lunghezza 6.

```{r}
programsT %>%
  mutate(programs_L = sapply(programs,length)) %>%
  filter(programs_L != 6)
```

Posso quindi espandere i programmi.

```{r}
programsT <- programsT %>% unnest_wider(programs)
programsT %>% distinct(programID)
programsT %>% select(programID) %>% n_distinct() # ci sono 14531 programmi
```

Nella maggior parte dei casi a un programma è associato un concerto, ma non è sempre così. In totale ci sono 22525 concerti.

```{r}
programsT %>%
  mutate(concerts_L=sapply(concerts,length)) %>%
  count(concerts_L) %>%
  mutate(concertN = concerts_L * n) %>%
  mutate(concertsT = cumsum(concertN)) %>%
  arrange(-concertsT)
```

Espando i concerti, ottengo una riga per ogni concerto. Passo da 14.536 a 22.525 righe. Aggiungo anche una colonna concertID. Passo a 7 colonne.

```{r}
programsT <- programsT %>% unnest_longer(concerts)
nrow(programsT)
programsT <- rowid_to_column(programsT,var = "concertID")
programsT <- select(programsT,id,programID,orchestra,season,concertID,concerts,works)
```

Verifico che ogni concerto abbia 5 campi.

```{r}
programsT %>%
  mutate(concerts_L = sapply(concerts, length)) %>%
  filter(concerts_L != 5)
```

Posso espandere con unnest_wider. Allargo il tibble di 4 colonne, al posto di concerts ho eventType, Location, Venue, Date e Time.

```{r}
programsT <- programsT %>% unnest_wider(concerts)

```

Come si può vedere, un programma può contenere più concerti.

```{r}
programsT %>% group_by(programID) %>% count(sort = TRUE)
```

Per esempio il programma 10700 contiene 16 concerti. In questo caso vediamo anche che di alcuni concerti non è indicata l'ora.
Per questo motivo ho introdotto un concertID, se in seguito mi fossi limitato a identificare il concerto con eventType, Location, Venue, Date, Time, avrei perso alcuni concerti.

```{r}
programsT %>%
  filter(programID == 10700)
```

Ogni programma contiene un certo numero di lavori (works). In totale ci sono 125.224 works (si tratta di works che possono essere ripetuti in diversi programs).	

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L) %>%
  mutate(works_N = works_L * n) %>%
  mutate(works_T = cumsum(works_N)) %>%
  arrange(-works_T)
```

Ci sono dei program che hanno 0 works, che cosa sono? Si tratta di eventi che non prevedono musica o dei quali mancano informazioni.

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  filter(works_L == 0)
```

Posso utilizzare unnest_longer, ogni lavoro associato a un programma darà origine a una riga. Devo usare l'opzione keep_empty TRUE per non perdere le righe con zero works.
Quindi il tibble passerà a 125.224 + 29 righe, ovvero 125.253.

```{r}
programsT <- programsT %>% unnest_longer(works, keep_empty = TRUE)
programsT %>% filter(programID == 13665)
```

Ora works contiene liste di lunghezze diverse, a seconda delle caratteristiche del work compreso. 

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L)
```

Le liste di lunghezza 3 sono quelle che contengono le intermissions.

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 3) %>%
  select(works) %>%
  unnest_wider(works) %>%
  count(ID, interval, soloists)
```

Cerco di capire cosa contengono le altre liste (di lunghezza 4, 5 e 6). 

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 4) %>%
  select(works) %>%
  unnest_wider(works)
```

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 5) %>%
  select(works) %>%
  unnest_wider(works)
```

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 6) %>%
  select(works) %>%
  unnest_wider(works)
```

Faccio unnest_wider di works. Passo da 11 colonne a 17 (al posto di works si aggiungono tutte le colonne comuni ai diversi works, ovvero ID, composerName, workTitle, movement, conductorName, soloists, interval)

```{r}
programsT <- programsT %>% unnest_wider(works)
```

Passo a prendere in considerazione workTitle.

```{r}
programsT %>%
  mutate(workTitle_L = sapply(workTitle,length)) %>%
  count(workTitle_L)
```

Come sono gli elementi di lunghezza 2.

```{r}
programsT %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  pull(workTitle) %>%
  head(3)
```

Mi salvo i program ID per ritrovarli dopo la modifica.

```{r}
wt2ids <- programsT %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  select(ID)
```

Applico funzione per sistemarli (sistemo anche NA al posto di NULL), faccio semi_join con gli id per verificare il risultato su quelli di lunghezza 2.

```{r}
mod_w <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (combine_w(x[[1]], x[[2]]))
}

combine_w <- function(x,y) {
  if (startsWith(x,",")) {
    return (paste(y,x))
  } else {
    return (paste(x,y))
  }
}

programsT %>%
  mutate(workTitle = sapply(workTitle, mod_w)) %>%
  semi_join(wt2ids) %>%
  select(workTitle)
```

Eseguo l'operazione e ri-assegno a programsT.

```{r}
programsT <- programsT %>%
  mutate(workTitle = sapply(workTitle, mod_w))
```

Verifico la lunghezza degli elementi contenuti in movement.

```{r}
programsT %>%
  mutate(movement_L = sapply(movement, length)) %>%
  count(movement_L)
```

Vedo come sono quelli di lunghezza 2.

```{r}
programsT %>%
  mutate(movement_L = sapply(movement, length)) %>%
  filter(movement_L == 2)
```

Mi limito a concatenarli, con la funzione mod_m. Inoltre sostituisco i NULL con NA.

```{r}
mod_m <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (paste(x[[1]], "_", x[[2]]))
}

programsT <- programsT %>% mutate(movement = sapply(movement, mod_m))
```

Controllo la lunghezza delle liste contenute in soloists. Ho 89.321 potenziali righe di informazioni su solisti + 85.122 righe nulle.

```{r}
programsT %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  count(soloists_L) %>%
  mutate(soloists_N = soloists_L * n) %>%
  mutate(soloists_T = cumsum(soloists_N)) %>%
  filter(soloists_L == 0 | soloists_L == max(soloists_L))
```

Provo unnest_longer di soloists con opzione keep_empty per tenere anche le righe che contengono liste NULL e vedo che sono di lunghezza 0 o 3.

```{r}
programsT %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  count(soloists_L)
```

Ce ne sono cinque che sono di lunghezza 1, ma poi NULL.

```{r}
programsT %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  filter(soloists_L != 0) %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  mutate(soloists_L2 = sapply(soloists, length)) %>%
  filter(soloists_L2 == 0)
```

Per esempio.

```{r}
programsT %>%
  filter(programID == 14489)
```


```{r}
programsT %>%
  filter(concertID == 1)
```

Faccio quindi unnest_longer, poi unnest_wider, il numero di colonne passa da 17 a 19 (soloistName, soloistInstrument e soloistRoles al posto di soloists).

```{r}
programsT <- programsT %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  unnest_wider(soloists)
programsT
```

id rappresenta il GUID, che fa parte dell'indirizzo a cui è possibile vedere il programma online (archives.nyphil.org/index.php/artifact/GUID/fullview).
ci sono tre programID che sono associati a più GUID.
Tengo comunque la colonna id.

```{r}
ids <- programsT %>%
  distinct(id, programID) %>%
  group_by(programID) %>%
  count(sort = TRUE) %>%
  filter(n>1) %>%
  select(programID) %>%
  ungroup()

semi_join(programsT, ids) %>%
  distinct(id, programID) %>%
  select(id, programID)
```

Correggo come è scritta la data, aggiungo anche componenti anno, mese, giorno della data.

```{r}

#ci sono 5591 righe che contengono None invece dell'orario in formato AM o PM
programsT %>%
  mutate(trovato = str_detect(programsT$Time, "\\d{1,2}:\\d{1,2}[P,A]M")) %>%
  filter(trovato == FALSE)

# lascio Time com'è, sistemo la data, tenendo anche anno, mese, giorno
programsT <- programsT %>%
  mutate(Date = str_extract(Date, "[[:digit:]-]+")) %>%
  mutate(Date = ymd(Date)) %>%
  mutate(Year = year(Date)) %>%
  mutate(Month = month(Date)) %>%
  mutate(Day = day(Date)) %>%
  select(id, programID, orchestra, season, concertID, eventType, Location, Venue, Date, Year, Month, Day, Time, ID, composerName, workTitle, conductorName, soloistName, soloistInstrument, soloistRoles, movement, interval)

```

Divido ID in workID e movementID

```{r}
programsT <- programsT %>%
  separate(ID, into = c("workID", "movID"), sep = "\\*") %>%
  mutate(workID = as.integer(workID)) %>%
  mutate(movID = as.integer(movID))
```

Creo un tibble con solo i concerti.

```{r}
concerts <- programsT %>%
  distinct(concertID, eventType, Location, Venue, Date, Year, Month, Day, Time)
  
```

Venue negli anni.

```{r}
concerts %>%
  group_by(Year) %>%
  count(Venue) %>%
  ggplot(aes(x = Year, y = n, color = Venue)) +
    geom_line(alpha = 1/3, show.legend = FALSE)
```
Venue per anno.

```{r}
concerts %>%
  group_by(Year) %>%
  count(Venue) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  mutate(
    max = max(perc),
    min = min(perc)
  ) %>%
  filter(perc == max) %>%
  ggplot(aes(x = Year, y = n, color = Venue)) +
    geom_point(alpha = 1/3)
```

```{r}
concerts %>%
  group_by(Year) %>%
  count(Venue) %>%
  filter(Year == 1901)
```

```{r}
concerts %>%
  group_by(Year) %>%
  count(Venue) %>%
  filter(Year >= 1875 & Year <= 1925) %>%
  ggplot(aes(x = Year, y = n, color = Venue)) +
    geom_line(alpha = 1/3, show.legend = FALSE)
```

```{r}
concerts %>%
  group_by(Year) %>%
  count(Venue) %>%
  ggplot(aes(x = Year, y = n, color = Venue)) +
    geom_point(alpha = 1/3, show.legend = FALSE)
```

```{r}
concerts %>%
  group_by(Year) %>%
  group_by(Venue, .add = TRUE) %>%
  count()
```

Locations per anno. La più presente.

```{r}
concerts %>%
  group_by(Year) %>%
  count(Location) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  mutate(
    max = max(perc),
    min = min(perc)
  ) %>%
  filter(perc == max) %>%
  ggplot(aes(x = Year, y = n, color = Location)) +
    geom_point(alpha = 1/3)
```

Le seconde location per anno.

```{r}
concerts %>%
  group_by(Year) %>%
  count(Location) %>%
  mutate(total = sum(n)) %>%
  mutate(perc = n / total) %>%
  mutate (
    first = max(perc),
    second = nth(perc,2)
  ) %>%
  filter(perc == second) %>%
  ggplot(aes(x = Year, y = n, color = Location)) +
    geom_jitter(alpha = 1/3, show.legend = FALSE)
```

Quante Location per anno.

```{r}
concerts %>%
  distinct(Year,Location) %>%
  group_by(Year) %>%
  count()
```

Date.

```{r}
concerts %>%
  group_by(Month, Day) %>%
  summarise(n = n()) %>%
  arrange(-n)
```






Quanti concerti a stagione, andamento.

```{r}
concerts %>%
  group_by(Year) %>%
  count() %>%
  ggplot(mapping = aes(x = Year, y = n)) + 
  geom_point() +
  geom_smooth()
```

Che tipi di concerti ci sono.

```{r}
concerts %>%
  group_by(eventType) %>%
  count() %>%
  filter(n > 100) %>%
  ggplot(aes(x = n, y = eventType)) +
  geom_bar(stat = "identity")
```

Andamento limitandosi alla stagione regolare.

```{r}
concerts %>%
  filter(eventType == "Subscription Season") %>%
  group_by(Year) %>%
  count() %>%
  ggplot(mapping = aes(x = Year, y = n)) + 
  geom_point() +
  geom_smooth()
```

Andamento negli anni delle altre tipologie di concerti.

```{r}
concerts %>%
  filter(eventType != "Subscription Season") %>%
  group_by(Year) %>%
  count() %>%
  ggplot(mapping = aes(x = Year, y = n)) + 
  geom_point() +
  geom_smooth()
```

Mi concentro sul periodo che va dal 1975 ad oggi.

```{r}
concerts %>%
  filter(Year >= 1975 & Year < 2020) %>%
  mutate(group = if_else(eventType == "Subscription Season", "SUB", "REST")) %>%
  group_by(Year,group) %>%
  count() %>%
  ggplot(aes(x = Year, y = n, colour = group)) +
  geom_point() +
  geom_smooth()
```

```{r}
concerts %>%
  filter(Year >= 1975 & Year < 2020) %>%
  mutate(group = if_else(eventType == "Subscription Season", "SUB", "REST")) %>%
  group_by(Year,group) %>%
  count()
```

Quali sono gli eventType forti dal 1990 in poi?

```{r}
concerts %>%
  filter(Year >= 1990 & Year < 2020) %>%
  filter(eventType != "Subscription Season") %>%
  group_by(Year,eventType) %>%
  count() %>%
  ggplot(aes(x = Year, y = n, color = eventType)) +
  geom_line(alpha = 1/2, show.legend = FALSE)
```
```{r}
concerts %>%
  filter(Year >= 1990  & Year < 2020) %>%
  filter(eventType != "Subscription Season") %>%
  group_by(Year,eventType) %>%
  count() %>%
  filter(n > 10) %>%
  ggplot(aes(x = Year, y = n, color = eventType)) +
  geom_line(alpha = 1/2)
```

1990-2020

```{r}
concerts %>%
  filter(Year >= 1990 & Year < 2020) %>%
  filter(eventType != "Subscription Season") %>%
  group_by(Year,eventType) %>%
  count() %>%
  filter(n>5) %>%
  ggplot(aes(x = Year, y = n, color = eventType)) +
  geom_line() +
  facet_wrap(~eventType)
```

```{r}
concerts %>%
  filter(eventType == "Tour") %>%
  group_by(Year) %>%
  count() %>%
  ggplot(aes(x = Year, y = n)) +
  geom_line() +
  geom_smooth()
```

```{r}
concerts %>%
  filter(eventType == "Subscription Season") %>%
  group_by(Year) %>%
  count() %>%
  ggplot(aes(x = Year, y = n)) +
  geom_line()
```

```{r}
concerts %>%
  filter(eventType == "Subscription Season") %>%
  filter(Year >= 1910 & Year <= 1930) %>%
  group_by(Year) %>%
  count() %>%
  ggplot(aes(x = Year, y = n)) +
  geom_line()
```


Quanti compositori sono stati rappresentati.

```{r}
programsT %>%
  filter(!is.na(composerName)) %>%
  distinct(composerName) %>%
  count()
```

Quali sono stati i compositori più rappresentati? Conto quante rappresentazioni sono state fatte per ciascun compositore.
Considero i lavori, quindi i workID, se nello stesso concerto sono stati rappresentati più movimenti di uno stesso lavoro, il conteggio è comunque uno.

```{r}
programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(composerName) %>%
  count(sort = TRUE)

```

Come si sono evolute le rappresentazioni per compositore negli anni.

```{r}
programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(Year,composerName) %>%
  count() %>%
ggplot(aes(Year, n, color = composerName)) +
  geom_line(alpha = 1/2, show.legend = FALSE)
```

Quali compositori sono stati rappresentati più a lungo?

```{r}
programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(composerName) %>%
  summarise(
    first = min(Date),
    last = max(Date),
    timeSpan = (last - first) + 1
  ) %>%
  arrange(-timeSpan)
```

Densità di rappresentazioni.

```{r}
#da fare
```

Costruisco un modello lineare anno-rappresentazioni per tutti i compositori.

```{r}
#trovo i compositori che compaiono in solo 5 anni o meno per poi toglierli
fiveorless <- programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(composerName) %>%
  summarise(years = n_distinct(Year)) %>%
  filter(years <= 5)

yc <- programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  anti_join(fiveorless) %>%
  group_by(composerName,Year) %>%
  count() %>%
  group_by(composerName) %>%
  nest()

yc_model <- function(df) {
  lm(n ~ Year, data = df)
}

yc <- yc %>%
  mutate(model = map(data, yc_model))

yc <- yc %>%
  mutate(augment = map(model, augment))

models <- unnest(yc, augment)

# 10 modelli che variano di più
mostvar <- models %>%
  group_by(composerName) %>%
  summarise(
    start = min(.fitted),
    end = max(.fitted),
    difference = end - start
  ) %>%
  arrange(-difference) %>%
  head(15)

# li plotto
models %>%
  semi_join(mostvar) %>%
  ggplot(mapping = aes(x = Year, y = .fitted, color = composerName)) +
  geom_line(alpha = 1/2)

# provo a plottare i valori reali con modello
unnest(yc, c(data,augment), names_sep = "_") %>%
semi_join(select(mostvar,composerName)) %>%
select(composerName,data_Year,data_n,augment_.fitted) %>%
ggplot(mapping = aes(x = data_Year, y = data_n, color = composerName)) +
  geom_line(mapping = aes(x = data_Year, y = data_n, color = composerName), alpha = 1/2) +
  geom_line(mapping = aes(x = data_Year, y = augment_.fitted), color = "blue") +
  facet_wrap(vars(composerName))

ggplot(mapping = aes(x = Year, y = .fitted, color = composerName)) +
  geom_line(alpha = 1/2, show.legend = FALSE)


models %>%
  filter(.fitted > 20) %>%
  ggplot(mapping = aes(x = Year, y = .fitted, color = composerName)) +
  geom_line(alpha = 1/2)

minoridiuno <- yc %>%
  mutate(tidied = map(model, tidy)) %>%
  select(composerName,tidied) %>%
  unnest(tidied) %>%
  select(term, estimate) %>%
  mutate(term = str_replace(term, "\\(Intercept\\)", "Intercept")) %>%
  pivot_wider(names_from = term, values_from = estimate) %>%
  ungroup() %>%
  select(composerName, Intercept, Year) %>%
  filter(Year < 1)

programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  anti_join(minoridiuno, by = join_by(composerName)) %>%
  group_by(Year,composerName) %>%
  count() %>%
ggplot(aes(Year, n, color = composerName)) +
  geom_line(alpha = 1/2)

```

Vedo come sono i residui.

```{r}
yc <- yc %>% 
  mutate(data = map2(data, model, add_residuals))

resids <- unnest(yc, data)

resids %>%
  group_by(composerName)
  
yc <- yc %>% 
  mutate(glance = map(model, broom::glance))
  
glance = unnest(yc, glance)

glance %>%
  arrange(r.squared)
  
bad_fit <- filter(glance, r.squared < 0.001)

programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(composerName,Year) %>%
  count() %>%
  semi_join(bad_fit, by = "composerName") %>%
  ggplot(aes(Year, n, colour = composerName)) +
    geom_line() +
  facet_wrap(~composerName)

  count() %>%
  filter(n>50) %>%
  ungroup() %>%
  ggplot(aes(Year, resid)) +
    geom_line(aes(group = composerName), alpha = 1 / 3) + 
    geom_smooth(se = FALSE) +
    facet_wrap(~composerName) +
    theme_classic()

```

```{r}
#trovo i compositori che compaiono in solo 5 anni o meno per poi toglierli
fiveorless <- programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(composerName) %>%
  summarise(years = n_distinct(Year)) %>%
  filter(years <= 5)

yc <- programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  anti_join(fiveorless) %>%
  group_by(composerName,Year) %>%
  count() %>%
  group_by(composerName) %>%
  nest()

yc_model <- function(df) {
  gam(n ~ Year, data = df)
}

yc <- yc %>%
  mutate(model = map(data, yc_model))

yc <- yc %>%
  mutate(augment = map(model, augment))

models <- unnest(yc, augment)

# 10 modelli che variano di più
mostvar <- models %>%
  group_by(composerName) %>%
  summarise(
    start = min(.fitted),
    end = max(.fitted),
    difference = end - start
  ) %>%
  arrange(-difference) %>%
  head(10)

# li plotto
models %>%
  semi_join(mostvar) %>%
  ggplot(mapping = aes(x = Year, y = .fitted, color = composerName)) +
  geom_line(alpha = 1/2)

# provo a plottare i valori reali con modello
unnest(yc, c(data,augment), names_sep = "_") %>%
semi_join(select(mostvar,composerName)) %>%
select(composerName,data_Year,data_n,augment_.fitted) %>%
ggplot(mapping = aes(x = data_Year, y = data_n, color = composerName)) +
  geom_line(mapping = aes(x = data_Year, y = data_n, color = composerName), alpha = 1/2) +
  geom_line(mapping = aes(x = data_Year, y = augment_.fitted), color = "blue") +
  facet_wrap(vars(composerName))

ggplot(mapping = aes(x = Year, y = .fitted, color = composerName)) +
  geom_line(alpha = 1/2, show.legend = FALSE)


models %>%
  filter(.fitted > 20) %>%
  ggplot(mapping = aes(x = Year, y = .fitted, color = composerName)) +
  geom_line(alpha = 1/2)

minoridiuno <- yc %>%
  mutate(tidied = map(model, tidy)) %>%
  select(composerName,tidied) %>%
  unnest(tidied) %>%
  select(term, estimate) %>%
  mutate(term = str_replace(term, "\\(Intercept\\)", "Intercept")) %>%
  pivot_wider(names_from = term, values_from = estimate) %>%
  ungroup() %>%
  select(composerName, Intercept, Year) %>%
  filter(Year < 1)

programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,workID,composerName) %>%
  filter(!is.na(composerName)) %>%
  anti_join(minoridiuno, by = join_by(composerName)) %>%
  group_by(Year,composerName) %>%
  count() %>%
ggplot(aes(Year, n, color = composerName)) +
  geom_line(alpha = 1/2)

```












```{r}
concerts <-
  programsT %>%
  select(eventType,Location,Venue,Date,Year,Month,Day,Time)

# ci sono 22407 concerti
concerts <- 
  concerts %>%
  unique()
```

che tipo di concerti ci sono

```{r}
ggplot(data = concerts) +
  geom_bar(mapping = aes(y = eventType))
```

```{r}
concerts %>%
  count(Location, sort = TRUE)
```

```{r}
ggplot(concerts) +
  geom_bar(mapping = aes(x = month(Date)))
```


```{r}
concerts %>%
  filter(Location == "Ann Arbor, MI") %>%
  arrange(Date)
```









```{r}
programsT %>%
  distinct(eventType,Location,Venue,Date,Year,Time,composerName) %>%
  filter(!is.na(composerName)) %>%
  group_by(Year,composerName) %>%
  count(sort = TRUE)
```

```{r}
programsT %>%
  filter(str_detect(composerName, "Mendelssohn"), Year == 1950) %>%
  arrange(Date) %>%
  select(programID,season,eventType,Location,Venue,Date,Time,workID,composerName,workTitle) %>%
  distinct(eventType,Location,Venue,Date,Time,workID,workTitle)
```






```{r}
library
ggplot(gapminder, aes(year, lifeExp)) +
    geom_line(aes(group = country), alpha = 1/3) +
    theme_classic()
```

















































Cerco di capire che cosa contengono.

```{r}
works <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 3) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

first <- works[[1]]

identical_to_first <- lapply(works, identical, first)

works4 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 4) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works4_first <- works4[[1]]
id_to_first_w4 <- lapply(works4, identical, works4_first)
every(id_to_first_w4, isTRUE)

works5 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 5) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works5_first <- works5[[1]]
id_to_first_w5 <- lapply(works5, identical, works5_first)
every(id_to_first_w5, isTRUE)
detect_index(id_to_first_w5, isFALSE)
works5[[18]]
length(id_to_first_w5)
sum(unlist(id_to_first_w5))

works6 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 6) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works6_first <- works6[[1]]
id_to_first_w6 <- lapply(works6, identical, works6_first)
every(id_to_first_w6, isTRUE)

```

Faccio unnest_wider di works, controllo di aver mantenuto le informazioni di partenza.

```{r}
programsT <- programsT %>% mutate(works_L = sapply(works, length))
prova <- programsT %>% unnest_wider(works)
prova %>% filter(works_L == 3) # deve essere 18489
prova %>% filter(works_L == 4)
prova %>% filter(works_L == 5)
prova %>% filter(works_L == 6)
prova %>% filter(!is.na(conductorName))
prova
```

Controllo la lunghezza delle liste contenute in soloists.

```{r}
# da fare meglio
```

Faccio unnest_longer() su solisti e quindi unnest_wider().

```{r}
prova <- unnest_longer(prova, soloists, keep_empty = TRUE) # spiegare perché
prova <- unnest_wider(prova, soloists) # aumento da 17 a 19 le colonne ? e mi sono anche sistemato il problema del NULL
```

Verifico la lunghezza degli elementi contenuti in movement. Ci sono 148 elementi che hanno lunghezza 2.

```{r}
prova %>%
  mutate(movement_L = sapply(movement, length)) %>%
  count(movement_L)
```

Guardo a quelli che hanno lunghezza 2.

```{r}
prova %>%
  mutate(movement_L = sapply(movement, length)) %>%
  filter(movement_L == 2)
```





Applico funzione per sistemarli

```{r}
mod_w <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (combine_w(x[[1]], x[[2]]))
}

combine_w <- function(x,y) {
  if (startsWith(x,",")) {
    return (paste(y,x))
  } else {
    return (paste(x,y))
  }
}

prova <- prova %>% mutate(workTitle = sapply(workTitle, mod_w))

prova %>%
  filter(str_detect(workTitle, "PROCESSION"))
```

Correggo come è scritta la data.

```{r}
prova %>% separate(Date, into = c("date", "time"), sep = "T") %>%
  count(time)

# elimino time perché non è attendibile
prova %>%
  separate(Date, into = c("date", "time"), sep = "T") %>%
  unite(new, date, Time, sep = " ") %>%
  select(-time) %>%
  mutate(Date = parse_date_time(new, "%y-%m-%d %H:%M%p")) %>%
  select(-new) %>%
  select(id, programID, orchestra, season, eventType, Location, Venue, Date, everything())
# attenzione al warning
```

Posso rimuovere la colonna id?

```{r}
p1 <- prova %>% select(programID, id)
p1d <- distinct(p1)
length(unique(p1$programID)) # 14502 programID unici
length(unique(p1$id)) # 14507 id unici

# voglio trovare valori di programID che sono associati a più di un id
p1 %>% group_by(programID) %>% count(id) %>% count(programID, sort = TRUE) # qui ne vedo tre

p1 %>% group_by(id) %>% count(programID) %>% count(id, sort = TRUE)











p2 <- p1
anti_join(p1, p2, by=c("programID", "id"))
anti_join(p1, p2, by=c("id", "programID"))
prova %>% group_by("id") %>% group_by("programID") %>% count()
inner_join(p1,p2,"id")
distinctALL <- distinct(p1, programID, id)
distinctID <- prova %>% distinct(id)
distinctPID <- prova %>% distinct(programID)
anti_join(distinctALL,distinctPID)
str(prova)

all(!is.na(prova$id))
all(!is.na(prova$programID))
p2 <- rename(p2,programID2 = programID, id2 = id)
check <- tibble(p1,p2)

checkf <- function(a,b,c,d) {
  if (a == b) {
    if (b == d) {
      return (TRUE)
    } else {
      return (FALSE)
    }
  }
}
str(check)
sapply(check, checkf, a = programID, b = id, c = programID2, d = id2)
pmap(check,checkf)
```

Quanti programmi ci sono nel dataset?

```{r}
prova %>% group_by(Time) %>% count(sort = TRUE)

prova %>% group_by(Location) %>% count(sort = TRUE)

prova %>% filter(programID == 13158)
```

vecchia cosa per date e time

```{r}
programsT %>% separate(Date, into = c("date", "time"), sep = "T") %>%
  count(time)

# elimino time perché non è attendibile
prova %>%
  separate(Date, into = c("date", "time"), sep = "T") %>%
  unite(new, date, Time, sep = " ") %>%
  select(-time) %>%
  mutate(Date = parse_date_time(new, "%y-%m-%d %H:%M%p")) %>%
  select(-new) %>%
  select(id, programID, orchestra, season, eventType, Location, Venue, Date, everything())
# attenzione al warning

programsT %>%
  mutate(date = sapply(Date,function (x) str_extract(x, "[[:digit:]-]+")))

programsT %>%
  mutate(dt = str_extract(programsT$Date, "[[:digit:]-]+")) %>%
  mutate(dtt = str_c(dt, " ", programsT$Time)) %>%
  mutate(dateTime = parse_date_time(dtt, "%y-%m-%d %I:%M%p"))

programsT %>%
  mutate(dt = str_extract(programsT$Date, "[[:digit:]-]+")) %>%
  mutate(date = parse_date(dt)) 


  mutate(dtt = str_c(dt, " ", programsT$Time)) %>%
  mutate(dateTime = parse_date_time(dtt, "%y-%m-%d %I:%M%p"))


str_extract(x, "[[:digit:]-]+")

length(str_extract(programsT$Date, "\\d+-\\d+-\\d+"))
str_extract("1842-12-07T05:00:00Z", "[[:digit:]-]+")
as_datetime("1842-12-07 8:00PM")

length(str_extract(programsT$Time, "\\d+:\\d+PM"))
str_extract("8:00PM", "PM")
is.na(programsT$Time)
length(programsT$Date
       
       )

sum(is.na(c(NA,NA,3)))


programsT <- programsT %>%
  mutate(Time = str_replace(Time, "None", "")) %>%
  mutate(Date = str_c(str_extract(Date, "[[:digit:]-]+"),Time)) %>%
  mutate(Date = parse_date_time(Date, c("%y-%m-%d %I:%M%p","%y-%m-%d"))) %>%
  select(programID, orchestra, season, eventType, Location, Venue, Date, Time, ID, composerName, workTitle, conductorName, soloistName, soloistInstrument, soloistRoles, movement, interval)


```

La colonna "interval" contiene intermission di vari tipi.

```{r}
intervalNA <- programsT %>%
  filter(!is.na(interval)) %>%
  count()

intervalNome <- programsT %>%
  filter(str_detect(interval, "Intermission")) %>%
  count()
  
intervalNA == intervalNome
```

Compositori & direttori.

```{r}
cc <- programsT %>%
  filter(is.na(interval)) %>%
  distinct(concertID, Date, composerName, workTitle, conductorName)
  
cc %>%
  group_by(conductorName) %>%
  n_distinct(Date)

cc %>%
  filter(is.na(composerName))
  
programsT %>%
  filter(concertID == 577)
```

Primo e ultimo concerto per direttori. Densità di concerti.

```{r}
cc %>%
  filter(!is.na(conductorName), conductorName != "Not conducted") %>%
  group_by(conductorName) %>%
  summarise (
    first = min(Date),
    last = max(Date),
    span = last - first + 1
  ) %>%
  arrange(-span)

cc %>%
  filter(!is.na(conductorName), conductorName != "Not conducted") %>%
  distinct(concertID,conductorName) %>%
  group_by(conductorName) %>%
  count()

cc %>%
  filter(conductorName == "Abbado, Roberto") 

cc %>%
  filter(conductorName == "Ravel, Maurice")

cc %>%
  filter(conductorName == "Alsop, Marin")

```




