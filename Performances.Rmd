---
title: "Performances"
output: html_document
date: "2023-03-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyr)
library(dplyr)
#library(repurrrsive)
library(jsonlite)
library(purrr)
library(stringr)
library(lubridate)
```

Apro il file JSON, per come è fatto devo accedere al primo elemento e posso quindi caricarlo in un tibble.
Sono 14.536 liste.

```{r}
complete <- read_json("complete.json")
programs <- complete[[1]]
programsT <- tibble(programs)
```

A questo punto ho la possibilità di accedere ai programmi, controllo che siano tutte liste di lunghezza 6.

```{r}
programsT %>%
  mutate(programs_L = sapply(programs,length)) %>%
  filter(programs_L != 6)
```

Posso quindi espandere i programmi.

```{r}
programsT <- programsT %>% unnest_wider(programs)
```

Nella maggior parte dei casi a un programma è associato un concerto, ma non è sempre così. 

```{r}
programsT %>%
  mutate(concerts_L=sapply(concerts,length)) %>%
  count(concerts_L)
```

Espando i concerti, ottengo una riga per ogni concerto.

```{r}
programsT <- programsT %>% unnest_longer(concerts)
```

Verifico che ogni concerto abbia 5 campi.

```{r}
programsT %>%
  mutate(concerts_L = sapply(concerts, length)) %>%
  filter(concerts_L != 5)
```

Posso espandere con unnest_wider. Allargo il tibble di 4 colonne, al posto di concerts ho eventType, Location, Venue, Date e Time.

```{r}
programsT <- programsT %>% unnest_wider(concerts)
```

Ogni programma contiene un certo numero di lavori (works).

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L)
```

Posso utilizzare unnest_longer, ogni lavoro associato a un programma darà origine a una riga.

```{r}
programsT <- programsT %>% unnest_longer(works)
```

Ora works contiene liste di lunghezze diverse, a seconda delle caratteristiche del lavoro. 

```{r}
programsT %>%
  mutate(works_L=sapply(works,length)) %>%
  count(works_L) %>%
  add_tally(n)
```

Le liste di lunghezza 3 sono quelle che contengono le intermissions.

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 3) %>%
  select(works) %>%
  unnest_wider(works) %>%
  count(ID, interval, soloists)
```

Cerco di capire cosa contengono le altre liste (di lunghezza 4, 5 e 6). 

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 4) %>%
  select(works) %>%
  unnest_wider(works)
```

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 5) %>%
  select(works) %>%
  unnest_wider(works)
```

```{r}
programsT %>%
  mutate(works_L = sapply(works,length)) %>%
  filter(works_L == 6) %>%
  select(works) %>%
  unnest_wider(works)
```

Faccio unnest_wider di works. Passo da 10 colonne a 16 (al posto di works si aggiungono tutte le colonne comuni ai diversi works, ovvero ID, composerName, workTitle, movement, conductorName, soloists, interval)

```{r}
programsT <- programsT %>% unnest_wider(works)
```

Passo a prendere in considerazione workTitle.

```{r}
programsT %>%
  mutate(workTitle_L = sapply(workTitle,length)) %>%
  count(workTitle_L)
```

Come sono gli elementi di lunghezza 2.

```{r}
programsT %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  pull(workTitle)
```

Mi salvo i program ID per ritrovarli dopo la modifica.

```{r}
wt2ids <- programsT %>%
  mutate(workTitle_L = sapply(workTitle, length)) %>%
  filter(workTitle_L == 2) %>%
  select(ID)
```

Applico funzione per sistemarli (sistemo anche NA al posto di NULL), faccio semi_join con gli id per verificare il risultato su quelli di lunghezza 2.

```{r}
mod_w <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (combine_w(x[[1]], x[[2]]))
}

combine_w <- function(x,y) {
  if (startsWith(x,",")) {
    return (paste(y,x))
  } else {
    return (paste(x,y))
  }
}

programsT %>%
  mutate(workTitle = sapply(workTitle, mod_w)) %>%
  semi_join(wt2ids) %>%
  select(workTitle)
```

Eseguo l'operazione e ri-assegno a programsT.

```{r}
programsT <- programsT %>%
  mutate(workTitle = sapply(workTitle, mod_w))
```

Verifico la lunghezza degli elementi contenuti in movement.

```{r}
programsT %>%
  mutate(movement_L = sapply(movement, length)) %>%
  count(movement_L)
```

Vedo come sono quelli di lunghezza 2.

```{r}
programsT %>%
  mutate(movement_L = sapply(movement, length)) %>%
  filter(movement_L == 2)
```

Mi limito a concatenarli, con la funzione mod_m. Inoltre sostituisco i NULL con NA.

```{r}
mod_m <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (paste(x[[1]], "_", x[[2]]))
}

programsT <- programsT %>% mutate(movement = sapply(movement, mod_m))
```

Controllo la lunghezza delle liste contenute in soloists.

```{r}
programsT %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  count(soloists_L)
```

Provo unnest_longer di soloists con opzione keep_empty per tenere anche le righe che contengono liste NULL e vedo che sono tutte liste di lunghezza 3, tranne alcune di lunghezza 0.

```{r}
programsT %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  mutate(soloists_L = sapply(soloists, length)) %>%
  count(soloists_L)
```

Faccio quindi unnest_longer, poi unnest_wider, il numero di colonne passa da 16 a 18 (soloistName, soloistInstrument e soloistRoles al posto di soloists).

```{r}
programsT <- programsT %>%
  unnest_longer(soloists, keep_empty = TRUE) %>%
  unnest_wider(soloists)
programsT
```

id rappresenta il GUID, che fa parte dell'indirizzo a cui è possibile vedere il programma online (archives.nyphil.org/index.php/artifact/GUID/fullview). posso buttarlo?
ci sono tre programID che sono associati a più GUID

```{r}
ids <- programsT %>%
  distinct(id, programID) %>%
  group_by(programID) %>%
  count(sort = TRUE) %>%
  filter(n>1) %>%
  select(programID) %>%
  ungroup()

semi_join(programsT, ids) %>%
  distinct(id, programID) %>%
  select(id, programID)
```

Posso quindi eliminare la colonna id.

```{r}
programsT <- programsT %>%
  select(-id)
```

Correggo come è scritta la data, aggiungo anche seasonStart di tipo intero e componenti anno, mese, giorno della data.

```{r}

#ci sono 5582 righe che contengono None invece dell'orario in formato AM o PM
programsT %>%
  mutate(trovato = str_detect(programsT$Time, "\\d{1,2}:\\d{1,2}[P,A]M")) %>%
  filter(trovato == FALSE)

# lascio Time com'è, sistemo la data, tenendo solo anno, mese, giorno, aggiungo seasonStart e trasformo tipo intero
programsT <- programsT %>%
  mutate(seasonStart = str_extract(season, "\\d+")) %>%
  mutate(seasonStart = as.integer(seasonStart)) %>%
  mutate(Date = str_extract(Date, "[[:digit:]-]+")) %>%
  mutate(Date = ymd(Date)) %>%
  mutate(Year = year(Date)) %>%
  mutate(Month = month(Date)) %>%
  mutate(Day = day(Date)) %>%
  select(programID, orchestra, season, seasonStart, eventType, Location, Venue, Date, Year, Month, Day, Time, ID, composerName, workTitle, conductorName, soloistName, soloistInstrument, soloistRoles, movement, interval)

```

Quanti concerti a stagione, andamento.

```{r}
programsT %>%
  distinct(seasonStart,eventType,Location,Venue,Date,Year,Month,Day,Time) %>%
  group_by(Year) %>%
  count() %>%
  ggplot() + 
  geom_point(mapping = aes(x = Year, y = n))
```

Limitandosi alla subscription season.

```{r}
programsT %>%
  distinct(seasonStart,eventType,Location,Venue,Date,Year,Month,Day,Time) %>%
  filter(eventType == "Subscription Season") %>%
  group_by(Year) %>%
  count() %>%
  ggplot() + 
  geom_point(mapping = aes(x = Year, y = n))
```

```{r}
programsT %>%
  distinct(seasonStart,eventType,Location,Venue,Date,Year,Month,Day,Time) %>%
  filter(eventType == "Tour") %>%
  group_by(Year) %>%
  count() %>%
  ggplot() + 
  geom_point(mapping = aes(x = Year, y = n))

```

```{r}
programsT %>%
  distinct(seasonStart,eventType,Location,Venue,Date,Year,Month,Day,Time) %>%
  filter(eventType == "Tour") %>%
  group_by(Year) %>%
  count() %>%
  filter(n>75)
```




Durata delle stagioni.

```{r}
programsT %>%
  distinct(eventType)
```
























































Cerco di capire che cosa contengono.

```{r}
works <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 3) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

first <- works[[1]]

identical_to_first <- lapply(works, identical, first)

works4 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 4) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works4_first <- works4[[1]]
id_to_first_w4 <- lapply(works4, identical, works4_first)
every(id_to_first_w4, isTRUE)

works5 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 5) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works5_first <- works5[[1]]
id_to_first_w5 <- lapply(works5, identical, works5_first)
every(id_to_first_w5, isTRUE)
detect_index(id_to_first_w5, isFALSE)
works5[[18]]
length(id_to_first_w5)
sum(unlist(id_to_first_w5))

works6 <- programsT %>%
  mutate(works_L = sapply(works, length)) %>%
  filter(works_L == 6) %>%
  mutate(works_N = lapply(works, names)) %>%
  pull(works_N)

works6_first <- works6[[1]]
id_to_first_w6 <- lapply(works6, identical, works6_first)
every(id_to_first_w6, isTRUE)

```

Faccio unnest_wider di works, controllo di aver mantenuto le informazioni di partenza.

```{r}
programsT <- programsT %>% mutate(works_L = sapply(works, length))
prova <- programsT %>% unnest_wider(works)
prova %>% filter(works_L == 3) # deve essere 18489
prova %>% filter(works_L == 4)
prova %>% filter(works_L == 5)
prova %>% filter(works_L == 6)
prova %>% filter(!is.na(conductorName))
prova
```

Controllo la lunghezza delle liste contenute in soloists.

```{r}
# da fare meglio
```

Faccio unnest_longer() su solisti e quindi unnest_wider().

```{r}
prova <- unnest_longer(prova, soloists, keep_empty = TRUE) # spiegare perché
prova <- unnest_wider(prova, soloists) # aumento da 17 a 19 le colonne ? e mi sono anche sistemato il problema del NULL
```

Verifico la lunghezza degli elementi contenuti in movement. Ci sono 148 elementi che hanno lunghezza 2.

```{r}
prova %>%
  mutate(movement_L = sapply(movement, length)) %>%
  count(movement_L)
```

Guardo a quelli che hanno lunghezza 2.

```{r}
prova %>%
  mutate(movement_L = sapply(movement, length)) %>%
  filter(movement_L == 2)
```





Applico funzione per sistemarli

```{r}
mod_w <- function(x) {
  if (is.null(x)) return (NA)
  if (length(x) == 1) return (x[[1]])
  if (length(x) == 2) return (combine_w(x[[1]], x[[2]]))
}

combine_w <- function(x,y) {
  if (startsWith(x,",")) {
    return (paste(y,x))
  } else {
    return (paste(x,y))
  }
}

prova <- prova %>% mutate(workTitle = sapply(workTitle, mod_w))

prova %>%
  filter(str_detect(workTitle, "PROCESSION"))
```

Correggo come è scritta la data.

```{r}
prova %>% separate(Date, into = c("date", "time"), sep = "T") %>%
  count(time)

# elimino time perché non è attendibile
prova %>%
  separate(Date, into = c("date", "time"), sep = "T") %>%
  unite(new, date, Time, sep = " ") %>%
  select(-time) %>%
  mutate(Date = parse_date_time(new, "%y-%m-%d %H:%M%p")) %>%
  select(-new) %>%
  select(id, programID, orchestra, season, eventType, Location, Venue, Date, everything())
# attenzione al warning
```

Posso rimuovere la colonna id?

```{r}
p1 <- prova %>% select(programID, id)
p1d <- distinct(p1)
length(unique(p1$programID)) # 14502 programID unici
length(unique(p1$id)) # 14507 id unici

# voglio trovare valori di programID che sono associati a più di un id
p1 %>% group_by(programID) %>% count(id) %>% count(programID, sort = TRUE) # qui ne vedo tre

p1 %>% group_by(id) %>% count(programID) %>% count(id, sort = TRUE)











p2 <- p1
anti_join(p1, p2, by=c("programID", "id"))
anti_join(p1, p2, by=c("id", "programID"))
prova %>% group_by("id") %>% group_by("programID") %>% count()
inner_join(p1,p2,"id")
distinctALL <- distinct(p1, programID, id)
distinctID <- prova %>% distinct(id)
distinctPID <- prova %>% distinct(programID)
anti_join(distinctALL,distinctPID)
str(prova)

all(!is.na(prova$id))
all(!is.na(prova$programID))
p2 <- rename(p2,programID2 = programID, id2 = id)
check <- tibble(p1,p2)

checkf <- function(a,b,c,d) {
  if (a == b) {
    if (b == d) {
      return (TRUE)
    } else {
      return (FALSE)
    }
  }
}
str(check)
sapply(check, checkf, a = programID, b = id, c = programID2, d = id2)
pmap(check,checkf)
```

Quanti programmi ci sono nel dataset?

```{r}
prova %>% group_by(Time) %>% count(sort = TRUE)

prova %>% group_by(Location) %>% count(sort = TRUE)

prova %>% filter(programID == 13158)
```

vecchia cosa per date e time

```{r}
programsT %>% separate(Date, into = c("date", "time"), sep = "T") %>%
  count(time)

# elimino time perché non è attendibile
prova %>%
  separate(Date, into = c("date", "time"), sep = "T") %>%
  unite(new, date, Time, sep = " ") %>%
  select(-time) %>%
  mutate(Date = parse_date_time(new, "%y-%m-%d %H:%M%p")) %>%
  select(-new) %>%
  select(id, programID, orchestra, season, eventType, Location, Venue, Date, everything())
# attenzione al warning

programsT %>%
  mutate(date = sapply(Date,function (x) str_extract(x, "[[:digit:]-]+")))

programsT %>%
  mutate(dt = str_extract(programsT$Date, "[[:digit:]-]+")) %>%
  mutate(dtt = str_c(dt, " ", programsT$Time)) %>%
  mutate(dateTime = parse_date_time(dtt, "%y-%m-%d %I:%M%p"))

programsT %>%
  mutate(dt = str_extract(programsT$Date, "[[:digit:]-]+")) %>%
  mutate(date = parse_date(dt)) 


  mutate(dtt = str_c(dt, " ", programsT$Time)) %>%
  mutate(dateTime = parse_date_time(dtt, "%y-%m-%d %I:%M%p"))


str_extract(x, "[[:digit:]-]+")

length(str_extract(programsT$Date, "\\d+-\\d+-\\d+"))
str_extract("1842-12-07T05:00:00Z", "[[:digit:]-]+")
as_datetime("1842-12-07 8:00PM")

length(str_extract(programsT$Time, "\\d+:\\d+PM"))
str_extract("8:00PM", "PM")
is.na(programsT$Time)
length(programsT$Date
       
       )

sum(is.na(c(NA,NA,3)))


programsT <- programsT %>%
  mutate(Time = str_replace(Time, "None", "")) %>%
  mutate(Date = str_c(str_extract(Date, "[[:digit:]-]+"),Time)) %>%
  mutate(Date = parse_date_time(Date, c("%y-%m-%d %I:%M%p","%y-%m-%d"))) %>%
  select(programID, orchestra, season, eventType, Location, Venue, Date, Time, ID, composerName, workTitle, conductorName, soloistName, soloistInstrument, soloistRoles, movement, interval)


```


